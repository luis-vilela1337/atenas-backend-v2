import {
  CreateOrderInput,
  CreateOrderResult,
  Order,
  OrderItemDetail,
} from '../entities/order.entity';
import { OrderRepositoryInterface } from '../repositories/order.repository.interface';
import { MercadoPagoRepositoryInterface } from '../../mercado-pago/repositories/mercado-pago.repository.interface';
import { PaymentPreference } from '../../mercado-pago/entities/payment-preference.entity';
import { UserSQLRepository } from '../../../infra/data/sql/repositories/user.repository';
import { ConfigService } from '@nestjs/config';

export class CreateOrderUseCase {
  constructor(
    private readonly orderRepository: OrderRepositoryInterface,
    private readonly mercadoPagoRepository: MercadoPagoRepositoryInterface,
    private readonly userRepository: UserSQLRepository,
    private readonly configService: ConfigService,
  ) {}

  async execute(input: CreateOrderInput): Promise<CreateOrderResult> {
    try {
      // 1. Calculate total amount
      const totalAmount = input.cartItems.reduce(
        (sum, item) => sum + item.totalPrice,
        0,
      );

      // 2. Handle free orders
      if (totalAmount === 0) {
        const order = await this.createOrder(input, totalAmount, 'APPROVED');
        return {
          orderId: order.id,
          checkoutUrl: this.configService.get('BATATA_CHECKOUT_URL'),
          paymentMethod: 'FREE',
        };
      }

      // 3. Check user credit
      const userCredit = await this.userRepository.findUserCreditByUserId(
        input.userId,
      );
      if (userCredit >= totalAmount) {
        // Deduct credit
        await this.userRepository.updateUserCredit(
          input.userId,
          userCredit - totalAmount,
        );

        const order = await this.createOrder(input, totalAmount, 'APPROVED');
        return {
          orderId: order.id,
          checkoutUrl: this.configService.get('BATATA_CHECKOUT_URL'),
          paymentMethod: 'CREDIT',
          creditUsed: totalAmount,
          remainingCredit: userCredit - totalAmount,
        };
      }

      // 4. Mercado Pago flow (existing code)
      const order = await this.createOrder(input, totalAmount, 'PENDING');

      // Create Mercado Pago preference
      const preference = this.createMercadoPagoPreference(order, input);
      const mercadoPagoResult =
        await this.mercadoPagoRepository.createPreference(preference);

      // Update order with payment gateway ID
      await this.orderRepository.updateOrderPaymentGatewayId(
        order.id,
        mercadoPagoResult.id,
      );

      return {
        orderId: order.id,
        checkoutUrl: mercadoPagoResult.checkoutUrl,
        paymentMethod: 'MERCADO_PAGO',
      };
    } catch (error) {
      throw new Error(`Failed to create order: ${error.message}`);
    }
  }

  private async createOrder(
    input: CreateOrderInput,
    totalAmount: number,
    paymentStatus: 'PENDING' | 'APPROVED' | 'REJECTED' | 'CANCELLED',
  ): Promise<Order> {
    const orderData: Partial<Order> = {
      userId: input.userId,
      totalAmount,
      paymentStatus,
      shippingAddress: input.shippingDetails,
      items: input.cartItems.map((item) => ({
        id: '', // Will be generated by repository
        productId: item.productId,
        productName: item.productName,
        productType: item.productType,
        itemPrice: item.totalPrice,
        details: this.createOrderItemDetails(item.selectionDetails),
      })),
    };

    return await this.orderRepository.createOrder(orderData as Order);
  }

  private createOrderItemDetails(selectionDetails: any): OrderItemDetail[] {
    const details: OrderItemDetail[] = [];

    // Handle photos selection (GENERIC and DIGITAL_FILES individual)
    if (selectionDetails.photos) {
      for (const photo of selectionDetails.photos) {
        details.push({
          id: '', // Will be generated by repository
          photoId: photo.id,
          eventId: photo.eventId,
          isPackage: false,
        });
      }
    }

    // Handle events selection (DIGITAL_FILES packages)
    if (selectionDetails.events) {
      for (const event of selectionDetails.events) {
        details.push({
          id: '', // Will be generated by repository
          photoId: undefined,
          eventId: event.id,
          isPackage: event.isPackage,
        });
      }
    }

    // Handle album photos (ALBUM)
    if (selectionDetails.albumPhotos) {
      for (const photoId of selectionDetails.albumPhotos) {
        details.push({
          id: '', // Will be generated by repository
          photoId: photoId,
          eventId: undefined,
          isPackage: false,
        });
      }
    }

    return details;
  }

  private createMercadoPagoPreference(
    order: Order,
    input: CreateOrderInput,
  ): PaymentPreference {
    return {
      items: order.items.map((item) => ({
        id: item.productId,
        title: item.productName,
        description: `${item.productName} - ${item.productType}`,
        quantity: 1,
        unit_price: item.itemPrice,
      })),
      payer: {
        name: input.payer.firstName,
        surname: input.payer.lastName,
        email: input.payer.email,
        phone: {
          area_code: input.payer.phone.areaCode,
          number: input.payer.phone.number,
        },
        address: {
          street_name: input.shippingDetails.street,
          street_number: input.shippingDetails.number,
          zip_code: input.shippingDetails.zipCode,
        },
      },
      externalReference: order.id, // Add order ID as external reference for webhook identification
    };
  }
}
